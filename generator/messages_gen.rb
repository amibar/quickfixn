

class MessageGen

  def self.generate messages, dir, fixver, fixbasever
    destdir = File.join(dir, fixver)
    Dir.mkdir(destdir) unless File.exists? destdir

    #basemsgstr = gen_basemsg(fixver,fixbasever,destdir)
    #basemsg_path = File.join(destdir, "Message.cs")
    #puts 'generate ' + basemsg_path
    #File.open(basemsg_path, 'w') {|f| f.puts(basemsgstr) }

    beginstring = fixbasever.match(/^FIX50/) ? "FIXT11" : fixbasever
	
	msgstr = gen_header(fixver)
	
    messages.each do |msg| 
      msgstr = msgstr + gen_msg(msg, fixver, beginstring)
    end
		
	msgstr = msgstr + gen_footer
	
    msg_path = File.join(destdir, 'Messages.cs')
    puts 'generate ' + msg_path
    File.open(msg_path, 'w') {|f| f.puts(msgstr) }
	
	
    #messages.each do |msg| 
     # msgstr = gen_msg(msg, fixver, beginstring)
#      msg_path = File.join(destdir, msg[:name] + '.cs')
      #puts 'generate ' + msg_path
      #File.open(msg_path, 'w') {|f| f.puts(msgstr) }
    #end
  end

  def self.lower rawstr
    str = rawstr.clone
    str.slice(0,1).downcase + str.slice(1,rawstr.length)
  end
 
  
def self.gen_header fixver
<<HERE
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
// </auto-generated>
//------------------------------------------------------------------------------

using QuickFix.Fields;
using QuickFix.#{fixver}.Fields;

namespace QuickFix.#{fixver}
{
HERE
end  

def self.gen_footer
<<HERE
}
HERE
end  

  def self.gen_msg msg, fixver, beginstring
<<HERE
	public class #{msg[:name]} : Message
	{
#{msgtype(msg)}
#{ctor(msg, beginstring)}
#{ctor_req(msg)}
#{gen_msg_fields(msg[:name], msg[:fields], 8)}
#{gen_msg_groups(msg[:groups], 8)}
	}
	
HERE
  end

  def self.msgtype msg
<<HERE
		public const string MsgType = "#{msg[:msgtype]}";
HERE
  end

  def self.ctor msg, beginstring
<<HERE
		public #{msg[:name]}()
		{
			this.Header.SetField(new QuickFix.Fields.BeginString(QuickFix.FixValues.BeginString.#{beginstring}));
			this.Header.SetField(new QuickFix.Fields.MsgType(MsgType));
		}
HERE
  end

  def self.ctor_req msg
    req = required_fields(msg)
    return '' if req.empty?
    req_args = req.map {|r| ' '*12 + "#{r[:name]} a#{r[:name]}" }
    req_setters = req.map {|r| ' '*12 + "this.#{(r[:name])} = a#{r[:name]};" }
<<HERE
		public #{msg[:name]}(
#{req_args.join(",\n")}
                ) : this()
		{
#{req_setters.join("\n")}
		}
HERE
  end

  def self.gen_msg_fields msg_name, fields, prepend_spaces
    fields.map { |fld| msg_field(msg_name, fld, prepend_spaces) }.join("\n")
  end

  def self.gen_msg_groups groups, prepend_spaces
    groups.map { |grp| msg_grp(grp, prepend_spaces) }.join("\n")
  end


  def self.required_fields msg
    msg[:fields].select {|f| f[:required] == true and f[:group] == false }
  end

  def self.msg_field msg_name, fld, prepend_spaces
  
    fld_name = fld[:name]
    if fld_name == msg_name
      fld_name = fld_name + '_'
    end 
    
    str = []
    str << "public #{fld[:name]} #{fld_name}"
    str << "{ "
    str << "    get "
    str << "    {"
    str << "        #{fld[:name]} val = new #{fld[:name]}();"
    str << "        GetField(val);"
    str << "        return val;"
    str << "    }"
    str << "    set { SetField(value); }"
    str << "}"
    str << ""
    str << "public void Set(#{fld[:name]} val) => this.#{fld_name} = val;"
    str << ""
    str << "public #{fld[:name]} Get(#{fld[:name]} val) "
    str << "{ "
    str << "    GetField(val);"
    str << "    return val;"
    str << "}"
    str << ""
    str << "public bool IsSet(#{fld[:name]} val) => IsSet#{fld[:name]}();"
    str << "public bool IsSet#{fld[:name]}() => IsSetField(Tags.#{fld[:name]});"
    str << ""
    str.map! {|s| ' '*prepend_spaces + s}
    str.join("\n")
  end

  def self.msg_grp grp, prepend_spaces
    str = []
    str << "public class #{grp[:name]}Group : Group"
    str << "{"
    str << "    public static int[] fieldOrder = {#{grp_field_order grp[:fields] }};"
    str << ""
    str << "    public #{grp[:name]}Group() "
    str << "      :base( Tags.#{grp[:group_field][:name]}, Tags.#{grp[:fields][0][:name]}, fieldOrder)"
    str << "    {"
    str << "    }"
    str << ""
    str << "    public override Group Clone()"
    str << "    {"
    str << "        var clone = new #{grp[:name]}Group();"
    str << "        clone.CopyStateFrom(this);"
    str << "        return clone;"
    str << "    }"
    str << ""
    str << gen_msg_fields('', grp[:fields], prepend_spaces+4)
    str << gen_msg_groups(grp[:groups], prepend_spaces+4)
    str << "}"
    str.map {|s| ' '*prepend_spaces + s}.join("\n")
  end

  def self.grp_field_order fields
    field_order = fields.map {|f| "Tags.#{f[:name]}"}
    field_order << "0"  ## um, because qf and qfj do it
    field_order.join(", ")
  end
end
