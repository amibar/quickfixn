class MessageFactoryGen
  def self.generate(messages, dir, fixver, fixbasever)
    destdir = File.join(dir,fixver)
    Dir.mkdir(destdir) unless File.exists?(destdir)
    file_path = File.join(destdir,"MessageFactory.cs")
    puts 'generate ' + file_path

    content = gen_factory(messages,fixver,fixbasever)
    File.open(file_path, 'w') {|f| f.puts(content)}
  end


  def self.gen_factory(messages,fixver,fixbasever)
return <<HERE
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
// </auto-generated>
//------------------------------------------------------------------------------

using System.IO;
using System.Reflection;

namespace QuickFix
{
    namespace #{fixver}
    {
        public class MessageFactory : IMessageFactory
        {
            private static readonly DataDictionary.DataDictionary _dataDictionary;
            public DataDictionary.DataDictionary DataDictionary => _dataDictionary;

            public FIXVersion[] SupportedFIXVersions { get; } = { FIXVersion.#{fixbasever}, };

            static MessageFactory()
            {
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("QuickFix.#{fixver}.#{fixver}.xml"))
                {
                    _dataDictionary = new DataDictionary.DataDictionary();
                    _dataDictionary.Load(stream);
                }
            }

#{gen_method_create(messages,fixver)}

#{gen_method_group(messages,fixver)}
        }
    }
}
HERE
  end


  def self.gen_method_create(messages,fixver)
return <<HERE
            public QuickFix.Message Create(string beginString, string msgType)
            {
                int mt = MsgTypes.GetMsgType(msgType);
            
                switch (mt)
                {
#{gen_method_create_cases(messages,fixver)}
                }

                if (SupportedFIXVersions[0].IsFIXT && Message.IsAdminMsgType(msgType))
                {
                    QuickFix.Message m = new QuickFix.Message();
                    m.Header.SetField(new QuickFix.Fields.StringField(QuickFix.Fields.Tags.MsgType, msgType));
                    return m;
                }

                return new QuickFix.Message();
            }
HERE
  end

  def self.gen_method_group(messages,fixver)
	
	method = gen_method_group_header
	
	groups_exists = messages.any? { |m| m[:groups].length > 0 }
	if (groups_exists) then
		method = method + gen_method_group_body(messages,fixver)
	end

	method = method + gen_method_group_footer
	
	return method

  end

  def self.gen_method_group_header
<<HERE
            public Group Create(string beginString, string msgType, int correspondingFieldID)
            {
HERE
end

  def self.gen_method_group_body (messages,fixver)
<<HERE			
                int mt = MsgTypes.GetMsgType(msgType);
                
                switch(mt)
                {
#{gen_method_group_cases(messages,fixver)}
                }
HERE
  end

  
  def self.gen_method_group_footer
<<HERE
                return null;
            }
HERE
  end
  
  
  
  
  def self.gen_method_create_cases(messages,fixver)
    indent = " "*4*5
    messages.map {|m|
        indent + "case MsgTypes.#{m[:name]}: return new #{m[:name]}();"
    }.join("\n")
  end

  def self.gen_method_group_cases(messages,fixver)
    indent = " "*4*5
    lines = Array.new
    messages.each {|m|
      if(m[:groups].length > 0)
        lines << indent + "case MsgTypes.#{m[:name]}:"
        lines << indent + "{"
        lines << indent + "    switch (correspondingFieldID)"
        lines << indent + "    {"

	m[:groups].each {|g|
		gen_method_group_groups(m,fixver,g,"",lines,indent)
        }

        lines << indent + "    }"
        lines << indent + "    break;"
        lines << indent + "}"
	lines << ""
      end
    }
    lines.join("\n")
  end
  
  
  def self.gen_method_group_groups(message,fixver,thisgroup,path,lines,indent)

	lines << indent + "        case Tags.#{thisgroup[:name]}: return new #{message[:name]}#{path}.#{thisgroup[:name]}Group();"
  
    thisgroup[:groups].each {|g| 
      gen_method_group_groups(message,fixver,g,"#{path}.#{thisgroup[:name]}Group",lines,indent);
    }
  end  
end
